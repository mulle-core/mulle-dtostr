# Agent and AI information

## MANDATORY FIRST STEPS - DO THIS IMMEDIATELY

ðŸš¨ **CRITICAL: YOU MUST DO THIS AT THE START OF EVERY CHAT SESSION** ðŸš¨

DO NOT skip these steps. DO NOT treat them as optional. DO NOT proceed with any
task until you have completed ALL of these commands in order:

### Step 1: REQUIRED - Enable vibecoding and read help

```bash
mulle-sde vibecoding on
mulle-sde help
```

### Step 2: REQUIRED - Read howto and api help

```bash
mulle-sde howto help
mulle-sde api help
```

### Step 3: REQUIRED - List available commands and howtos

```bash
mulle-sde commands
mulle-sde howto list
```

**REMEMBER**: `mulle-sde howto` is THE tool for getting work done in this
project. Use it FIRST before attempting any task manually.


## MANDATORY BEFORE WRITING ANY CODE

ðŸš¨ **YOU MUST RUN THIS COMMAND BEFORE WRITING OR MODIFYING ANY CODE** ðŸš¨

```bash
value="$(mulle-sde env get PROJECT_DIALECT)"
value="${value:-$(mulle-sde env get PROJECT_LANGUAGE)}"
mulle-sde howto show --keyword styleguide --keyword "${value}"
```

This gets the style information for the project. It is NOT optional.
## Library

This is a library project, you can not run it.
## C

This is a C project.

## CMake Guidelines

This section outlines the structure and conventions for CMake in this
project. Following these guidelines ensures a stable and predictable build.

### 1. File and Directory Roles

#### `CMakeLists.txt` (Project Root)

* **Purpose:** Main entry point for the CMake build process.
* **Guidelines:** Edit for high-level project settings. Use `mulle-sde` to manage
  source files (e.g., `mulle-sde add src/foo.m`).

#### `cmake/reflect/`

* **Purpose:** Auto-generated files by `mulle-sde reflect` to map the sourcetree
  into CMake-readable lists.
* **Guidelines:** **Do not edit**. Changes will be overwritten by `mulle-sde reflect`.

#### `cmake/share/`

* **Purpose:** Contains standard shared CMake modules.
* **Guidelines:** **Do not edit**. Changes will be overwritten by `mulle-sde upgrade`.

#### `cmake/`

* **Purpose:** Project-specific customizations for the build system.
* **Guidelines:** Copy and edit files from `cmake/share/` to override default modules.

### 2. Summary of Editing Rules

| Path             | Editable? | Notes                                                        |
| ---------------- | --------- | ------------------------------------------------------------ |
| `CMakeLists.txt` | Yes       | High-level project settings.                                 |
| `cmake/`         | Yes       | Override modules by copying from `cmake/share/`.             |
| `cmake/share/`   | No        | Managed by `mulle-sde upgrade`. Changes will be lost.        |
| `cmake/reflect/` | No        | Auto-generated by `mulle-sde reflect`. Changes will be lost. |
# mulle-dtostr Project Knowledge

## Overview
C implementation of the Schubfach algorithm for fast and accurate conversion of IEEE-754 `double` values to decimal strings. Originally converted from C++ (Victor Zverovich's implementation) to plain C.

## Key Files
- `mulle-dtostr.h` - Public API header
- `mulle-dtostr.c` - Implementation (~39KB, compiles to ~16KB object file)
- `example.c` - Simple usage example
- `test_compare.c` - Comparison test vs system printf
- `test_decompose.c` - Tests for decompose function

## API

### String Conversion
```c
void mulle_dtostr(double value, char* buffer);
```
- Converts double to shortest correctly rounded decimal string
- Always uses scientific notation (e.g., `1.e+00`, `3.141592653589793e+00`)
- Buffer must be at least `MULLE__DTOSTR_BUFFER_SIZE` (25 bytes)
- Special values: `inf`, `-inf`, `nan`, `-nan`, `0`, `-0`
- Early escape optimization for `1.0` â†’ `"1.e+00"`

### Decimal Decomposition (NEW)
```c
struct mulle_dtostr_decimal mulle_dtostr_decompose(double value);
```
Returns intermediate decimal representation:
```c
struct mulle_dtostr_decimal {
  uint64_t significand;  // decimal significand/mantissa
  int16_t  exponent;     // decimal exponent
  uint8_t  sign;         // 0 = positive, 1 = negative
  uint8_t  special;      // 0 = normal, 1 = inf, 2 = nan, 3 = zero
  uint32_t _padding;     // reserved (total: 16 bytes)
};
```

**Example:** `3.14159265358979323846` decomposes to:
- `significand = 31415926535897930`
- `exponent = -16`
- `sign = 0`
- `special = 0`
- Meaning: `3.1415926535897930 Ã— 10^0`

## Naming Conventions
- Uppercase constants: `MULLE__DTOSTR_*` (double underscore)
- Functions: `mulle_dtostr_*` prefix
- Struct: `mulle_dtostr_decimal`

## Integration with mulle-sprintf

### Current State
`mulle-sprintf` (in `../mulle-sprintf/src/functions/mulle-sprintf-fp.c`) currently uses `sprintf` to format floating-point values, which is inefficient.

### Integration Plan
Use `mulle_dtostr_decompose()` to get the intermediate representation, then format in `mulle-sprintf` based on:

**Format info available:**
- `info->conversion` - format character ('e', 'f', 'g', 'a', 'E', 'F', 'G', 'A')
- `info->precision` - decimal precision (e.g., `%.3f` = 3)
- `info->width` - field width (e.g., `%20f` = 20)
- `info->memory.hash_found` - alternate form flag (`#`)
- `info->memory.plus_found` - always show sign (`+`)
- `info->memory.space_found` - space for positive numbers
- `info->memory.zero_found` - zero padding
- `info->memory.minus_found` - left justify

**Formatting strategy:**
- `%e/%E`: Scientific notation (already have this from decompose)
- `%f/%F`: Fixed-point (shift significand by exponent)
- `%g/%G`: Choose between `%e` and `%f` based on exponent magnitude
- `%a/%A`: Hexadecimal (different algorithm, not yet implemented)

### Benefits of Decompose Approach
1. **Separation of concerns:** dtostr handles binaryâ†’decimal, sprintf handles formatting
2. **Flexibility:** sprintf can implement all format variations
3. **Efficiency:** 16-byte struct returns by value (fits in two registers)
4. **No string parsing:** Direct access to numeric components

## Implementation Details

### Algorithm
Schubfach algorithm - produces shortest correctly rounded decimal representation.

### Key Components
- `pow10_significands[]` - Pre-computed power-of-10 significands (generated by `gen-pow10.py`)
- `umul128()` - 128-bit multiplication helper
- `umul192_upper64_modified()` - Modified rounding for upper 64 bits
- `countl_zero_u64()` - Count leading zeros (manual implementation, no C++ std::countl_zero)

### Special Value Handling
- Zero: Early escape at exponent check (handles `+0.0` and `-0.0`)
- Infinity: Detected when `bin_exp == 0x7ff` and `bin_sig == 0`
- NaN: Detected when `bin_exp == 0x7ff` and `bin_sig != 0`
- 1.0: Early escape with direct comparison before bit manipulation

### C Conversion Notes
Original C++ code used:
- `std::bit_cast` â†’ replaced with union
- `std::countl_zero` â†’ manual implementation
- `std::numeric_limits` â†’ literal constants
- `namespace schubfach` â†’ prefix `mulle_dtostr_`
- `constexpr` â†’ `const` or `#define`
- `auto` â†’ explicit types

## Build & Test
```bash
# Compile
gcc -c -std=c99 mulle-dtostr.c

# Optimized build
gcc -c -Os -DNDEBUG -std=c99 mulle-dtostr.c

# Run example
gcc -std=c99 -o example example.c mulle-dtostr.c && ./example

# Run comparison test
gcc -std=c99 -o test_compare test_compare.c mulle-dtostr.c -lm && ./test_compare

# Run decompose test
gcc -std=c99 -o test_decompose test_decompose.c mulle-dtostr.c -lm && ./test_decompose
```

## Next Steps
1. Implement formatting functions in `mulle-sprintf` using `mulle_dtostr_decompose()`
2. Handle `%e`, `%f`, `%g` conversions with precision and width
3. Apply flags (sign, padding, justification)
4. Replace `sprintf` calls in `mulle-sprintf-fp.c`
5. Consider `%a` (hexadecimal) format if needed

## Performance
- Binary size: ~16KB (optimized)
- Fast formatting (see dtostr-benchmark results in README)
- Struct return by value is efficient (16 bytes = 2 registers)

## References
- Schubfach algorithm: https://drive.google.com/file/d/1IEeATSVnEE6TkrHlCYNY2GjaraBjOT4f
- Original C++ implementation: Victor Zverovich (MIT license)
- Benchmark: https://github.com/fmtlib/dtostr-benchmark

## Coding Style Guide

This document outlines the coding conventions. All contributions must adhere to
these rules to maintain code consistency and readability.

### 1. Formatting

#### 1.1. Indentation
-   Use three (3) spaces for each level of indentation. Do not use tabs.

#### 1.2. Bracing
-   Use the Allman style for braces. The opening and closing braces for a block
    are placed on their own lines and are vertically aligned.

    ```c
    if( condition)
    {
       ...
    }
    ```

#### 1.3. Spacing
-   **Control Structures & Function Calls:** No space between a
    keyword/function name and the opening parenthesis. A space follows the
    opening parenthesis.
    -   `if( condition)`
    -   `while( i < n)`
    -   `[self doSomethingWith: arg]`
-   **Expressions:** No spaces immediately inside parentheses for grouping
    expressions.
    -   `x = (a + b) * c;`

#### 1.4. Columnar Alignment
-   Align similar elements vertically for readability, especially assignment
    operators.

    ```c
    char  *a;
    int   b;

    a = "foo";
    b = 1848;
    ```

#### 1.5. `return` Statements
-   Parenthesize the return expression: `return( expr);`.
-   Do not use parentheses when there is no return value: `return;`.

### 2. Declarations & Initialization

#### 2.1. Variable Declaration
-   Declare all local variables at the top of the function block (C89 style).
-   Sort variable declarations alphabetically by name.
-   Declare one variable per line, except for trivial counters
    (e.g., `int i, n;`).

#### 2.2. Initialization
-   Variables should not be initialized at declaration by default.
-   **Exceptions:**
    1.  When initializing from a function argument, often involving a cast.
    2.  When initializing an aggregate type (struct, array) to zero, which
        replaces a subsequent `memset(..., 0, ...)`. If an aggregate is
        initialized this way, the corresponding `memset` must be removed.

### 3. Control Flow

#### 3.1. `case` and `goto` Labels
-   `case` statements and `goto` labels are not indented relative to the
    block they are in. They align with the opening brace of the `switch` or
    function block.

    ```c
    switch( value)
    {
    case 0:
       ...
       break;

    default:
       ...
       break;
    }
    ```

#### 3.2. Single-Statement Blocks
-   Avoid single-line statements for blocks (e.g., `if(condition) statement;`).
-   Use braces for all blocks, except for single-line statements, when it has
    no continuation and its visual association with the control structure is
    unambiguous.

## 4. Objective-C Specific

### 4.1. General coding style

-   Do not use `-retain` or `copy` or `-release` or `autorelease` (exception: inside `-init` and `-dealloc` and "accessor" methods)
-   Do not use `+alloc` `-init` use `+instance` or an appropriate factory method like `-[NSMutableArray array]`

### 4.2. Property Access
-   Do not use dot-syntax for property access.
-   Prefer non-mutable state in properties, prefer `(copy)` over `(retain)` when possible
-   Do not use strong use retain or copy instead
-   Do not use weak, use assign instead
-   Convert all property reads and writes to explicit message sends.
    -   **Read:** `[self property]` instead of `self.property`.
    -   **Write:** `[self setProperty:value]` instead of `self.property = value`.

