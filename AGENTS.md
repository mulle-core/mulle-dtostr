# mulle-dtoa Project Knowledge

## Overview
C implementation of the Schubfach algorithm for fast and accurate conversion of IEEE-754 `double` values to decimal strings. Originally converted from C++ (Victor Zverovich's implementation) to plain C.

## Key Files
- `mulle-dtoa.h` - Public API header
- `mulle-dtoa.c` - Implementation (~39KB, compiles to ~16KB object file)
- `example.c` - Simple usage example
- `test_compare.c` - Comparison test vs system printf
- `test_decompose.c` - Tests for decompose function

## API

### String Conversion
```c
void mulle_dtoa(double value, char* buffer);
```
- Converts double to shortest correctly rounded decimal string
- Always uses scientific notation (e.g., `1.e+00`, `3.141592653589793e+00`)
- Buffer must be at least `MULLE__DTOA_BUFFER_SIZE` (25 bytes)
- Special values: `inf`, `-inf`, `nan`, `-nan`, `0`, `-0`
- Early escape optimization for `1.0` → `"1.e+00"`

### Decimal Decomposition (NEW)
```c
struct mulle_dtoa_decimal mulle_dtoa_decompose(double value);
```
Returns intermediate decimal representation:
```c
struct mulle_dtoa_decimal {
  uint64_t significand;  // decimal significand/mantissa
  int16_t  exponent;     // decimal exponent
  uint8_t  sign;         // 0 = positive, 1 = negative
  uint8_t  special;      // 0 = normal, 1 = inf, 2 = nan, 3 = zero
  uint32_t _padding;     // reserved (total: 16 bytes)
};
```

**Example:** `3.14159265358979323846` decomposes to:
- `significand = 31415926535897930`
- `exponent = -16`
- `sign = 0`
- `special = 0`
- Meaning: `3.1415926535897930 × 10^0`

## Naming Conventions
- Uppercase constants: `MULLE__DTOA_*` (double underscore)
- Functions: `mulle_dtoa_*` prefix
- Struct: `mulle_dtoa_decimal`

## Integration with mulle-sprintf

### Current State
`mulle-sprintf` (in `../mulle-sprintf/src/functions/mulle-sprintf-fp.c`) currently uses `sprintf` to format floating-point values, which is inefficient.

### Integration Plan
Use `mulle_dtoa_decompose()` to get the intermediate representation, then format in `mulle-sprintf` based on:

**Format info available:**
- `info->conversion` - format character ('e', 'f', 'g', 'a', 'E', 'F', 'G', 'A')
- `info->precision` - decimal precision (e.g., `%.3f` = 3)
- `info->width` - field width (e.g., `%20f` = 20)
- `info->memory.hash_found` - alternate form flag (`#`)
- `info->memory.plus_found` - always show sign (`+`)
- `info->memory.space_found` - space for positive numbers
- `info->memory.zero_found` - zero padding
- `info->memory.minus_found` - left justify

**Formatting strategy:**
- `%e/%E`: Scientific notation (already have this from decompose)
- `%f/%F`: Fixed-point (shift significand by exponent)
- `%g/%G`: Choose between `%e` and `%f` based on exponent magnitude
- `%a/%A`: Hexadecimal (different algorithm, not yet implemented)

### Benefits of Decompose Approach
1. **Separation of concerns:** dtoa handles binary→decimal, sprintf handles formatting
2. **Flexibility:** sprintf can implement all format variations
3. **Efficiency:** 16-byte struct returns by value (fits in two registers)
4. **No string parsing:** Direct access to numeric components

## Implementation Details

### Algorithm
Schubfach algorithm - produces shortest correctly rounded decimal representation.

### Key Components
- `pow10_significands[]` - Pre-computed power-of-10 significands (generated by `gen-pow10.py`)
- `umul128()` - 128-bit multiplication helper
- `umul192_upper64_modified()` - Modified rounding for upper 64 bits
- `countl_zero_u64()` - Count leading zeros (manual implementation, no C++ std::countl_zero)

### Special Value Handling
- Zero: Early escape at exponent check (handles `+0.0` and `-0.0`)
- Infinity: Detected when `bin_exp == 0x7ff` and `bin_sig == 0`
- NaN: Detected when `bin_exp == 0x7ff` and `bin_sig != 0`
- 1.0: Early escape with direct comparison before bit manipulation

### C Conversion Notes
Original C++ code used:
- `std::bit_cast` → replaced with union
- `std::countl_zero` → manual implementation
- `std::numeric_limits` → literal constants
- `namespace schubfach` → prefix `mulle_dtoa_`
- `constexpr` → `const` or `#define`
- `auto` → explicit types

## Build & Test
```bash
# Compile
gcc -c -std=c99 mulle-dtoa.c

# Optimized build
gcc -c -Os -DNDEBUG -std=c99 mulle-dtoa.c

# Run example
gcc -std=c99 -o example example.c mulle-dtoa.c && ./example

# Run comparison test
gcc -std=c99 -o test_compare test_compare.c mulle-dtoa.c -lm && ./test_compare

# Run decompose test
gcc -std=c99 -o test_decompose test_decompose.c mulle-dtoa.c -lm && ./test_decompose
```

## Next Steps
1. Implement formatting functions in `mulle-sprintf` using `mulle_dtoa_decompose()`
2. Handle `%e`, `%f`, `%g` conversions with precision and width
3. Apply flags (sign, padding, justification)
4. Replace `sprintf` calls in `mulle-sprintf-fp.c`
5. Consider `%a` (hexadecimal) format if needed

## Performance
- Binary size: ~16KB (optimized)
- Fast formatting (see dtoa-benchmark results in README)
- Struct return by value is efficient (16 bytes = 2 registers)

## References
- Schubfach algorithm: https://drive.google.com/file/d/1IEeATSVnEE6TkrHlCYNY2GjaraBjOT4f
- Original C++ implementation: Victor Zverovich (MIT license)
- Benchmark: https://github.com/fmtlib/dtoa-benchmark
